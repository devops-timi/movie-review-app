---

# ─────────────────────────────────────────────
# WEB TIER
# ─────────────────────────────────────────────


- name: Configure Web Tier
  hosts: web
  become: yes

  tasks:
    - name: Update apt cache
      apt:
        update_cache: yes
        cache_valid_time: 3600  # Optional: skip if updated in the last hour
    
    - name: Install required packages
      apt:
        name:
          - nginx
          - docker.io
          - unzip       # needed for awscli zip
          - curl   
          - git     # needed to download awscli
        state: present

    - name: Install AWS CLI v2 if not present
      shell: |
        curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
        unzip awscliv2.zip
        ./aws/install
        rm -rf awscliv2.zip aws
        aws --version
      args:
        creates: /usr/local/bin/aws

    - name: Clone repository
      git:
        repo: "{{ repo_url }}"
        dest: /app
        version: main
        force: yes
      # Clones your GitHub repo into /app on the web instance
      # force: yes means if /app already exists it will update it
      # version: main means the main branch
      # repo_url comes from group_vars/all.yml

    - name: Ensure Docker service is started and enabled
      systemd:
        name: docker
        state: started
        enabled: yes
    
    - name: Add Ubuntu to docker group
      user:
        name: ubuntu
        groups: docker
        append: yes

    - name: Ensure Nginx is started and enabled
      systemd:
        name: nginx
        state: started
        enabled: yes
    
    - name: Reset connection to apply group changes
      ansible.builtin.meta: reset_connection

    - name: Copy nginx config from cloned repo
      copy:
        src: /app/nginx/nginx.conf
        dest: /etc/nginx/sites-available/movie-review
        remote_src: yes
        owner: root
        group: root
        mode: '0644'
      # remote_src: yes means the src path is on the remote instance
      # not on your laptop or the runner
      # It copies from /app/nginx/nginx.conf (cloned from repo)
      # to where nginx expects it
      notify: restart nginx
      
    - name: Enable nginx site
      file:
        src: /etc/nginx/sites-available/movie-review
        dest: /etc/nginx/sites-enabled/movie-review
        state: link
      notify: restart nginx

    - name: Remove default nginx site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      notify: restart nginx
      
    - name: Test Nginx configuration
      command: nginx -t
      register: nginx_test
      changed_when: false

    - name: Pull frontend image from Docker Hub
      community.docker.docker_image:
        name: "{{ frontend_image }}"
        source: pull

    - name: Run frontend container
      community.docker.docker_container:
        name: frontend
        image: "{{ frontend_image }}"
        state: started
        restart_policy: always
        ports:
          - "3000:3000"
        env:
          NEXT_PUBLIC_API_URL: "http://{{ internal_clb_dns }}:3010"
          NODE_ENV: "production"

    # ── Send SQL files to app instance ───────────
    # Web instance cloned the repo so it has the SQL files
    # App instance has no internet so it can't clone itself
    # We SCP just the two SQL files across the internal network

    - name: Copy SSH key to web instance
      copy:
        content: "{{ ssh_private_key }}"
        dest: /home/ubuntu/.ssh/connect.pem
        owner: ubuntu
        mode: '0600'
      # ssh_private_key comes from group_vars/all.yml
      # which reads it from the environment (GitHub secret)
      # mode 0600 = only owner can read — required by SSH

      # Copies directly from the cloned repo on the web instance
      # to the app instance over the internal VPC network
      # No internet involved at all

    
      # Web instance pulls the backend image since it has internet

  handlers:
    - name: restart nginx
      systemd:
        name: nginx
        state: restarted
      listen: restart nginx

# ─────────────────────────────────────────────
# APP TIER
# Reached via ProxyJump through web instance
# ─────────────────────────────────────────────
- name: Configure app tier
  hosts: app
  become: true

  tasks:

    - name: Update apt cache
      apt:
        update_cache: yes

    - name: Install Docker and MySQL
      apt:
        name:
          - mysql-client
          - git
          - docker.io
        state: present

    - name: Add ubuntu user to docker group
      user:
        name: ubuntu
        groups: docker
        append: yes

    - name: Ensure Docker is started and enabled
      systemd:
        name: docker
        state: started
        enabled: true

    - name: Reset connection to apply group changes
      ansible.builtin.meta: reset_connection

    - name: Pull backend image from Docker Hub
      community.docker.docker_image:
        name: "{{ backend_image }}"
        source: pull

    - name: Run backend container
      community.docker.docker_container:
        name: backend
        image: "{{ backend_image }}"
        state: started
        restart_policy: always
        ports:
          - "3010:3010"
        env:
          PORT: "3010"
          NODE_ENV: "production"
          DB_HOST: "{{ db_host }}"
          DB_PORT: "{{ db_port }}"
          DB_USER: "{{ db_user }}"
          DB_PASSWORD: "{{ db_password }}"
          DB_NAME: "{{ db_name }}"
          CORS_ORIGIN: "http://{{ public_clb_dns }}"
    
    - name: Clean up cloned repo
      file:
        path: /app
        state: absent
# ─────────────────────────────────────────────
# DATABASE
# Runs from the app instance → RDS
# SQL files were SCP'd here from the web instance
# ─────────────────────────────────────────────
- name: Import database
  hosts: app[0]
  become: true

  tasks:

    - name: Clone repository for SQL files
      git:
        repo: "{{ repo_url }}"
        dest: /app
        version: main
        force: yes

    - name: Import schema into RDS
      shell: |
        mysql -h {{ db_host }} \
              -P {{ db_port }} \
              -u {{ db_user }} \
              -p{{ db_password }} \
              {{ db_name }} < /app/database/schema.sql

      # Runs ON the app instance
      # App instance SG is allowed through DB SG on port 3306
      # mysql reads each line of schema.sql and executes it against RDS

    - name: Import seed data into RDS
      shell: |
        mysql -h {{ db_host }} \
              -P {{ db_port }} \
              -u {{ db_user }} \
              -p{{ db_password }} \
              {{ db_name }} < /app/database/seed.sql

    - name: Clean up
      file:
        path: /app
        state: absent